{"version":3,"file":"static/js/791.54fcb0de.chunk.js","mappings":"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","sources":["pages/Reversi/rule.js","pages/Reversi/ai.js"],"sourcesContent":["const DEFAULT_START_PLAYER = \"black\";\r\nconst DEFAULT_BOARD = [\r\n  [null, null, null, null, null, null, null, null],\r\n  [null, null, null, null, null, null, null, null],\r\n  [null, null, null, null, null, null, null, null],\r\n  [null, null, null, \"white-piece\", \"black-piece\", null, null, null],\r\n  [null, null, null, \"black-piece\", \"white-piece\", null, null, null],\r\n  [null, null, null, null, null, null, null, null],\r\n  [null, null, null, null, null, null, null, null],\r\n  [null, null, null, null, null, null, null, null],\r\n];\r\nconst DEFAULT_VALID_BOARD = getValidBoard(\r\n  findValidMoves(DEFAULT_BOARD, DEFAULT_START_PLAYER)\r\n);\r\nconst DEFAULT_PIEACES = countPieces(DEFAULT_BOARD);\r\n\r\nfunction getOpponent(player) {\r\n  return player === \"black\" ? \"white\" : \"black\";\r\n}\r\n\r\nfunction inBound(x, y) {\r\n  return x >= 0 && x < 8 && y >= 0 && y < 8;\r\n}\r\n\r\nfunction findFlankOpponentPieces(board, row, col, player, checkValidMove) {\r\n  const playerPieace = `${player}-piece`;\r\n  const opponentPieace = `${getOpponent(player)}-piece`;\r\n  const flanks = [];\r\n\r\n  // prettier-ignore\r\n  const directions = [\r\n      [-1, -1], [-1, 0], [-1, 1],\r\n      [ 0, -1],          [ 0, 1],\r\n      [ 1, -1], [ 1, 0], [ 1, 1],\r\n    ];\r\n\r\n  directions.forEach((direction) => {\r\n    const [dx, dy] = direction;\r\n    const squaresToFlip = [];\r\n    let x = row + dx;\r\n    let y = col + dy;\r\n\r\n    if (inBound(x, y) && board[x][y] === opponentPieace) {\r\n      while (inBound(x, y)) {\r\n        const square = board[x][y];\r\n        if (square === opponentPieace) {\r\n          squaresToFlip.push([x, y]);\r\n        } else if (square === null) {\r\n          break;\r\n        } else if (square === playerPieace) {\r\n          flanks.push(...squaresToFlip);\r\n          if (checkValidMove) return [flanks];\r\n          else break;\r\n        }\r\n\r\n        x += dx;\r\n        y += dy;\r\n      }\r\n    }\r\n  });\r\n\r\n  return flanks;\r\n}\r\n\r\nconst placePieaces = (board, player, row, col) => {\r\n  board[row][col] = `${player}-piece`;\r\n};\r\n\r\nconst flankOpponentPieces = (board, player, row, col) => {\r\n  const flanks = findFlankOpponentPieces(board, row, col, player);\r\n  flanks.forEach(([row, col]) => {\r\n    board[row][col] = `${player}-piece`;\r\n  });\r\n};\r\n\r\nconst updateBoard = (board, player, row, col) => {\r\n  const newBoard = JSON.parse(JSON.stringify(board));\r\n  placePieaces(newBoard, player, row, col);\r\n  flankOpponentPieces(newBoard, player, row, col);\r\n  return newBoard;\r\n};\r\n\r\nfunction findValidMoves(board, player) {\r\n  const validMoves = [];\r\n\r\n  board.forEach((row, i) => {\r\n    row.forEach((square, j) => {\r\n      if (square === null) {\r\n        const flanks = findFlankOpponentPieces(board, i, j, player, true);\r\n        if (flanks.length > 0) validMoves.push([i, j]);\r\n      }\r\n    });\r\n  });\r\n  return validMoves;\r\n}\r\n\r\nconst isGameOver = (board, validMoves) => {\r\n  const boardFull = board.every((row) =>\r\n    row.every((square) => square !== null)\r\n  );\r\n  const noValidMoves = validMoves.length === 0;\r\n  if (boardFull || noValidMoves) return true;\r\n  else return false;\r\n};\r\n\r\nfunction countPieces(board) {\r\n  let count = { black: 0, white: 0 };\r\n  board.forEach((row) => {\r\n    row.forEach((square) => {\r\n      if (square === \"black-piece\") count.black++;\r\n      else if (square === \"white-piece\") count.white++;\r\n    });\r\n  });\r\n  return count;\r\n}\r\n\r\nfunction getValidBoard(moves) {\r\n  const valid_board = [...Array(8)].map((row) =>\r\n    [...Array(8)].map((column) => false)\r\n  );\r\n  moves.forEach(([row, col]) => (valid_board[row][col] = true));\r\n  return valid_board;\r\n}\r\n\r\nexport {\r\n  DEFAULT_BOARD,\r\n  DEFAULT_START_PLAYER,\r\n  DEFAULT_VALID_BOARD,\r\n  DEFAULT_PIEACES,\r\n  updateBoard,\r\n  findValidMoves,\r\n  isGameOver,\r\n  getValidBoard,\r\n  countPieces,\r\n};\r\n","import { isGameOver, findValidMoves, updateBoard, countPieces } from \"./rule\";\r\n\r\nonmessage = function (e) {\r\n  const [board, player, depth] = e.data;\r\n  const result = getBestMove(board, player, depth);\r\n  postMessage(result);\r\n};\r\n\r\nfunction evaluate(board) {\r\n  const { black, white } = countPieces(board);\r\n  return black - white;\r\n}\r\n\r\nfunction alphaBeta(board, depth, alpha, beta, maximizingPlayer) {\r\n  let possibleMoves = null;\r\n  if (maximizingPlayer) possibleMoves = findValidMoves(board, \"black\");\r\n  else possibleMoves = findValidMoves(board, \"white\");\r\n\r\n  if (depth === 0 || isGameOver(board, possibleMoves)) {\r\n    const score = evaluate(board);\r\n    return score;\r\n  }\r\n\r\n  if (maximizingPlayer) {\r\n    let maxScore = -Infinity;\r\n    for (let move of possibleMoves) {\r\n      const newBoard = updateBoard(board, \"black\", move[0], move[1]);\r\n      const score = alphaBeta(newBoard, depth - 1, alpha, beta, false);\r\n      maxScore = Math.max(maxScore, score);\r\n      alpha = Math.max(alpha, score);\r\n      if (beta <= alpha) {\r\n        break;\r\n      }\r\n    }\r\n    return maxScore;\r\n  } else {\r\n    let minScore = Infinity;\r\n    for (let move of possibleMoves) {\r\n      const newBoard = updateBoard(board, \"white\", move[0], move[1]);\r\n      const score = alphaBeta(newBoard, depth - 1, alpha, beta, true);\r\n      minScore = Math.min(minScore, score);\r\n      beta = Math.min(beta, score);\r\n      if (beta <= alpha) {\r\n        break;\r\n      }\r\n    }\r\n    return minScore;\r\n  }\r\n}\r\n\r\nfunction getBestMove(board, player, depth) {\r\n  const maximize = player === \"black\";\r\n  const possibleMoves = findValidMoves(board, player);\r\n  let bestMove = null;\r\n\r\n  if (maximize) {\r\n    let maxScore = -Infinity;\r\n    possibleMoves.forEach((move) => {\r\n      const newBoard = updateBoard(board, \"black\", move[0], move[1]);\r\n      const score = alphaBeta(newBoard, depth - 1, maxScore, Infinity, false);\r\n      if (score > maxScore) {\r\n        bestMove = move;\r\n        maxScore = score;\r\n      }\r\n    });\r\n    return [bestMove, maxScore];\r\n  } else {\r\n    let minScore = Infinity;\r\n    possibleMoves.forEach((move) => {\r\n      const newBoard = updateBoard(board, \"white\", move[0], move[1]);\r\n      const score = alphaBeta(newBoard, depth - 1, -Infinity, minScore, true);\r\n      if (score < minScore) {\r\n        bestMove = move;\r\n        minScore = score;\r\n      }\r\n    });\r\n    return [bestMove, minScore];\r\n  }\r\n}\r\n"],"names":["DEFAULT_BOARD","moves","valid_board","Array","map","row","column","forEach","_ref2","col","getValidBoard","findValidMoves","countPieces","inBound","x","y","findFlankOpponentPieces","board","player","checkValidMove","playerPieace","opponentPieace","getOpponent","flanks","direction","dx","dy","squaresToFlip","square","push","updateBoard","newBoard","JSON","parse","stringify","placePieaces","flankOpponentPieces","_ref","validMoves","i","j","length","isGameOver","boardFull","every","noValidMoves","count","black","white","alphaBeta","depth","alpha","beta","maximizingPlayer","possibleMoves","score","evaluate","maxScore","Infinity","move","Math","max","minScore","min","onmessage","e","data","result","maximize","bestMove","getBestMove","postMessage"],"sourceRoot":""}